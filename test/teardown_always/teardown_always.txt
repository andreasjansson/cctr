%platform unix
===
cleanup any previous marker files
%require
===
rm -f /tmp/cctr_teardown_test_setup_ran /tmp/cctr_teardown_test_teardown_ran /tmp/cctr_teardown_test_main_ran
---

===
run suite with failing setup
%require
===
cctr $CCTR_FIXTURE_DIR/failing_setup --no-color 2>&1 || true
---
F.

âŠ˜ failing_setup: Setup failed (3 tests skipped)

Failures:

âœ— failing_setup/_setup: setup that fails
  {{ path }}_setup.txt:1
  Command: touch /tmp/cctr_teardown_test_setup_ran
false


Summary: 0 passed, 0 failed, 3 skipped in {{ t }}s
---
where
* t < 5
* path endswith "failing_setup/"

===
setup marker file exists
===
test -f /tmp/cctr_teardown_test_setup_ran && echo "setup ran"
---
setup ran

===
teardown marker file exists (CRITICAL - teardown must run even when setup fails)
===
test -f /tmp/cctr_teardown_test_teardown_ran && echo "teardown ran"
---
teardown ran

===
main test marker file does NOT exist (main tests skipped when setup fails)
===
test ! -f /tmp/cctr_teardown_test_main_ran && echo "main skipped"
---
main skipped

===
cleanup signal test markers
===
rm -f /tmp/cctr_signal_test_*
---

===
signal handling works when run directly (manual verification)
%skip(signal tests unreliable in subshell - verify manually: cctr fixture/slow_tests & sleep 0.8; kill -TERM $!)
===
# This test is skipped because signal handling behavior differs when running
# through bash -c vs directly. The signal handler works correctly when cctr
# is run directly, but in a subshell the process may be terminated before
# teardown can run. Manually verify with:
#   cctr test/teardown_always/fixture/slow_tests &
#   sleep 0.8
#   kill -TERM $!
# And check that /tmp/cctr_signal_test_teardown_ran exists.
true
---
